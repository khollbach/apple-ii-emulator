ex's of mode->location mapping:

A	    Accumulator	        OPC A	    operand is AC (implied single byte instruction)
abs	    absolute	        OPC $LLHH	operand is address $HHLL *
abs,X	absolute, X-indexed	OPC $LLHH,X	operand is address; effective address is address incremented by X with carry **
abs,Y	absolute, Y-indexed	OPC $LLHH,Y	operand is address; effective address is address incremented by Y with carry **
#	    immediate	        OPC #$BB	operand is byte BB
impl	implied	            OPC	        operand implied
ind	    indirect	        OPC ($LLHH)	operand is address; effective address is contents of word at address: C.w($HHLL)
X,ind	X-indexed, indirect	OPC ($LL,X)	operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X)
ind,Y	indirect, Y-indexed	OPC ($LL),Y	operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y
rel	    relative	        OPC $BB	    branch target is PC + signed offset BB ***
zpg	    zeropage	        OPC $LL	    operand is zeropage address (hi-byte is zero, address = $00LL)
zpg,X	zeropage, X-indexed	OPC $LL,X	operand is zeropage address; effective address is address incremented by X without carry **
zpg,Y	zeropage, Y-indexed	OPC $LL,Y	operand is zeropage address; effective address is address incremented by Y without carry **

mode, mode_arg      loc (maybe call it "Operand" and have a None variant)
============
A       --          reg A
abs	    $1234       mem $1234 -- for jumps, want mem_addr
abs,X	$1234       mem $123a
abs,Y	$1234       mem $123a
#	    $ab         lit $ab
impl	--          none
ind	    $1234       mem $5678 -- for jumps, we care about the mem_addr (not the value there)
X,ind	$55         mem $abcd
ind,Y	$56         mem $abc2
rel	    $ff         mem $aaa9 -- for branches, want mem_addr
zpg	    $55         mem $0055
zpg,X	$55         mem $005a
zpg,Y	$55         mem $005a

    flags:

arith:          N V Z C
{CMPs, shifts}: N - Z C
{xfer TO regs   N - Z -
 excl TXS(sp)
 incl loads
 incl PLA,
 logical,
 INC/DEC mem.}

{branches,      - - - -
 jumps,
 maybe some
 other stuff}

BIT is a special case: N V Z -
        (but not in the usual way)

---

todo: maybe refactor flags helpers somehow for more concise callsites
todo: maybe review the "nz" approach and consider if you like it.
todo: maybe refactor instr execution into a module with a bunch of
        shared state wrapped up in an object
todo: look into refactoring adc and sbc to share code
todo: I might not be using the same terminology as the reference:
        I think they're using "operand" to mean the "mode argument".
        Maybe we should re-name operand to location? (or something?)

